---
category: base
title: JVM---类加载
date: 2017-01-08 12:30:32
tags: Java
toc: true
---

<!--more-->
## 类的加载 
  .class文件读入到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类。
## 类加载过程
![](http://ocpue1vvp.bkt.clouddn.com/shunxu.png)
   除解析过程外，其他阶段顺序固定。解析阶段在某些情况下可以在初始化之后再开始，这是为了运行时动态绑定特性（JIT例如接口只在调用的时候才知道具体实现的是哪个子类）

---
**加载**:加载类的二进制数据

  通常也被称作“装载”，主要完成：
  - 通过“类全名”来获取定义此类的二进制字节流
  - 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
  - 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口
相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

---

**验证**:确保被加载的类的正确性

确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要验证：
 - 文件格式验证：
    验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
 - 元数据验证：
   对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外
 - 字节码验证
    通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
 - 符号引用验证
    确保解析动作能正确执行
---

**准备**:为类的静态变量分配内存，并将其初始化为默认值

 为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配
  - 内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
  - 初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
   ```
   public static int value = 3；
   ```
  变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

  这里还需要注意如下几点：

   1、对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
   2、对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
   3、对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
   4、如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值
   5、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
   假设上面的类变量value被定义为： 
   ```
   public static final int value = 3；
   ```
   编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中
---
**解析**:把类中的符号引用转换为直接引用

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口
  方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任
  何字面量。

---

 **初始化**

为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
   - 声明类变量是指定初始值
   - 使用静态代码块为类变量指定初始值

JVM初始化步骤

	1、假如这个类还没有被加载和连接，则程序先加载并连接该类
	2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
	3、假如类中有初始化语句，则系统依次执行这些初始化语句
	类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
	- 创建类的实例，也就是new的方式
	- 访问某个类或接口的静态变量，或者对该静态变量赋值
	- 调用类的静态方法
	- 反射（如Class.forName(“com.shengsiyuan.Test”)）
	- 初始化某个类的子类，则其父类也会被初始化
	- Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类
	结束生命周期
	在如下几种情况下，Java虚拟机将结束生命周期
	- 执行了System.exit()方法
	- 程序正常执行结束
	- 程序在执行过程中遇到了异常或错误而异常终止
	- 由于操作系统出现错误而导致Java虚拟机进程终止

---
## 类加载器  

![](http://ocpue1vvp.bkt.clouddn.com/classloader.png)

## 类加载方式

  有三种方式：
 1、命令行启动应用时候由JVM初始化加载
 2、通过Class.forName()方法动态加载
 3、通过ClassLoader.loadClass()方法动态加载
*注：
 **Class.forName()和ClassLoader.loadClass()区别:**
Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
ClassLoader.loadClass():只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

 ---










